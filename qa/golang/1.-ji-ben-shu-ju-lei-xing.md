---
description: >-
  数值类型, bool,
  string,byte,rune,pointer,array,slice,,map,channel,interface,method,func,struct
---

# 1. 基本数据类型

### 一、 数值类型 <a href="#item-1-1" id="item-1-1"></a>

#### 1. 整型 <a href="#item-1-1" id="item-1-1"></a>

`uint8`也就是`byte`型

|   无符号整型  | 取值范围                     |
| :------: | ------------------------ |
|  `uint8` | 0 到 255                  |
| `uint16` | 0 到 65535                |
| `uint32` | 0 到 4294967295           |
| `uint64` | 0 到 18446744073709551615 |

`int16`对应_C语言_中的`short`型，`int64`对应_C语言_中的`long`型

|  有符号整型  | 取值范围                                       |
| :-----: | ------------------------------------------ |
|  `int8` | -128 到 127                                 |
| `int16` | -32768 到 32767                             |
| `int32` | -2147483648 到 2147483647                   |
| `int64` | -9223372036854775808 到 9223372036854775807 |

**ⅰ. 特殊整型**

在使用`int`和`uint`类型时，不能假定它是32位或64位的整型，而是考虑`int`和`uint`可能在不同平台上的差异。

|    特殊整型   | 描述                                |
| :-------: | --------------------------------- |
|   `uint`  | 32位操作系统上就是uint32，64位操作系统上就是uint64 |
|   `int`   | 32位操作系统上就是int32，64位操作系统上就是int64   |
| `uintptr` | 无符号整型，长度被设定为足够存放一个指针              |

**ⅱ. 数字字面量语法**

```
const a = 0b00001101 // 二进制1101 == 十进制13
const b = 0333       // 0333 == 0o333，八进制333 == 十进制 64 * 3 + 3 * 8 + 3 = 219
const c = 0xAF       // 十六进制AF == 十进制 10 * 16 + 15 = 175
```

#### 2. 浮点型 <a href="#item-1-2" id="item-1-2"></a>

* `float32`精确到小数点后7位，最大范围可以使用常量定义：`math.MaxFloat32`
* `float64`精确到小数点后15位，最大范围可以使用常量定义：`math.MaxFloat64`。并且尽可能地使用`float64`，因为`math`包中所有有关数学运算的函数都会要求接收这个类型
* 使用`==`或者`!=`来比较浮点数时应当非常小心，最好在正式使用前测试对于精确度要求较高的运算

#### 3. 复数 <a href="#item-1-3" id="item-1-3"></a>

复数使用`re+imI`来表示，其中`re`代表实数部分，`im`代表虚数部分，`I`代表根号负1

* `complex64`，32位实数和虚数
* `complex128`，64位实数和虚数；最好使用`complex128`作为计算类型，因为相关函数都使用这个类型的参数。

```
var c1 complex64 = 5 + 10i // 5 + 10i == complex(5, 10)
fmt.Printf("输出：%v", c1) // 输出：5+10i
```

### 二、布尔值 <a href="#item-1-4" id="item-1-4"></a>

布尔型数据只有`true`和`false`两个值，默认为`false`

### 三、字符串 <a href="#item-1-5" id="item-1-5"></a>

字符串是一种值类型，且值不可变，更深入地讲，字符串是`byte类型`的固定长度数组。

Go语言支持以下2种形式字符串：

1.  解释字符串

    该类字符串使用双引号括起来，其中的相关的转义字符将被替换，这些转义字符包括：

    * ：换行符
    * ：回车符
    * ：tab 键
    * `\u`或`\U`：Unicode字符
    * `\\`：反斜杠自身
    * `\'`：单引号
    * `\"`：双引号
2.  非解释字符串

    该类字符串使用反引号括起来，支持换行，例如：

    ```
    package main

    import "fmt"

    func main() {
        const a = `\n：这里不会换行
    这里才会`

        // `\n：这里不会换行
        // 这里才会` 作为一个完整的字符串原样输出
        fmt.Println(a)
    }
    ```

**字符串拼接符`+`**

```
a := "我是A" + "，我5岁"
a += "，身高180cm"
fmt.Println(a) // 我是A，我5岁，身高180cm
```

**字符：`byte`和`rune`类型**

组成每个字符串的元素叫做字符，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号`'`包裹起来。

Go语言的字符有以下两种：

1. `uint8`类型，或者叫`byte`型，代表了`ASCII码`的一个字符
2. `rune`类型，代表一个`UTF-8`字符，`rune`类型实际是一个`int32`

Go语言使用了特殊的`rune`类型来处理Unicode，让基于Unicode的文本处理更为方便，也可以使用`byte`型进行默认字符串处理，性能和扩展性都有照顾。

```
s := "byte,no,rune我是"

for i := 0; i < len(s); i++ { //byte
    fmt.Printf("%v(%c) ", s[i], s[i])
}
fmt.Println()

for _, r := range s { //rune
    fmt.Printf("%v(%c) ", r, r)
}
fmt.Println()

// 98(b) 121(y) 116(t) 101(e) 44(,) 110(n) 111(o) 44(,) 114(r) 117(u) 110(n) 101(e) 230(æ) 136() 145() 230(æ) 152() 175(¯)
// 98(b) 121(y) 116(t) 101(e) 44(,) 110(n) 111(o) 44(,) 114(r) 117(u) 110(n) 101(e) 25105(我) 26159(是)
```

因为`UTF-8`编码下一个中文汉字由3\~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。

字符串底层是一个`byte`数组，所以可以和`[]byte`类型相互转换。字符串是不能修改的，字符串是由`byte`组成，所以字符串的长度是`byte`的长度。`rune`类型用来表示`utf-8`字符，一个`rune`字符由一个或多个`byte`组成。

### \* 类型转换 <a href="#item-2" id="item-2"></a>

Go语言中只有强制类型转换，没有隐式类型转换。

```
a, b := 3, 4
var c int
// math.Sqrt()接收的参数是float64类型，需要强制转换
c = int(math.Sqrt(float64(a*a + b*b)))
fmt.Println(c) // 5
```

\
